import {
  Meta,
  Source,
  Canvas,
  Controls,
  Markdown,
  Description,
} from "@storybook/blocks";
import * as ListFieldStories from "./ListField.stories";
import Props from "./props.md?raw";

<Meta title="components/ListField" />

# ListField

<Description of={ListFieldStories.Primary} />

```ts
import { ListField } from "@form-atoms/field";
```

<Canvas sourceState="none" of={ListFieldStories.Primary} />

```tsx
import {
  listField,
  ListField,
  textField,
  listFieldBuilder,
} from "@form-atoms/field";

const fields = {
  envVars: listField({
    value: [
      { variable: "GITHUB_TOKEN", value: "ff52d09a" },
      { variable: "NPM_TOKEN", value: "deepsecret" },
    ],
    builder: (item: { variable; value }) => ({
      variable: textField({ name: "variable", value: variable }),
      value: textField({ name: "value", value: value }),
      // Uncommenting the following line will make item.owner property available!
      // owner: textField({ name: "owner" }),
    }),
  }),
};

const Example = () => (
  <ListField
    field={fields.envVars}
    AddItemButton={({ add }) => (
      <button type="button" className="outline" onClick={add}>
        Add environment variable
      </button>
    )}
    RemoveItemButton={({ remove }) => (
      <button type="button" className="outline secondary" onClick={remove}>
        Remove
      </button>
    )}
  >
    {({ fields, RemoveItemButton }) => (
      <div
        style={{
          display: "grid",
          gridGap: 16,
          gridTemplateColumns: "auto auto min-content",
        }}
      >
        <InputField
          atom={fields.variable}
          render={(props) => <input {...props} placeholder="Variable Name" />}
        />
        <InputField
          atom={fields.value}
          render={(props) => <input {...props} placeholder="Variable Value" />}
        />
        <RemoveItemButton />
      </div>
    )}
  </ListField>
);
```

## Features

- ✅ **Optimized rendering**. the `keyFrom` prop will use the array item's field as stable render key. This is done internally, so you don't have to specify the `key` when the list is being rendered.
  This works thanks to Jotai's atom having `toString()` method providing stable `atomKey`.
- ✅ Can render `<EmptyMessage />` when array length is 0.
- ✅ Handles adding and removal of array items.
- ✅ Supports deeply nested arrays in arrays.

## Examples

### Flat

<Description of={ListFieldStories.Flat} />

<Canvas sourceState="none" of={ListFieldStories.Flat} />

```tsx
import {
  AddItemButtonProps,
  ListField,
  listField,
  listFieldBuilder,
  textField,
} from "@form-atoms/field";

const fields = {
  benefits: listField({
    value: ["safe function calls", "it's fast"],
    builder: (value) => textField({ name: "ts-benefit", value }),
  }),
};

const Example = () => (
  <>
    <label style={{ marginBottom: 16 }}>
      What are some benefits of TypeScript?
    </label>
    <ListField
      field={fields.benefits}
      AddItemButton={({ add }: AddItemButtonProps) => (
        <button type="button" className="outline" onClick={add}>
          Add Benefit
        </button>
      )}
    >
      {({ fields, RemoveItemButton }) => (
        <div
          style={{
            display: "grid",
            gridGap: 16,
            gridTemplateColumns: "auto min-content",
          }}
        >
          <InputField atom={fields} component="input" />
          <RemoveItemButton />
        </div>
      )}
    </ListField>
  </>
);
```

### Nested

ListField supports nested array fields.
For example we can capture multiple people with multiple banking accounts:

<Canvas sourceState="none" of={ListFieldStories.Nested} />

```tsx
const peopleForm = formAtom({
  // level 0
  people: [
    {
      name: fieldAtom({ value: "Jerry" }),
      // level 1 (nested)
      accounts: [{ iban: fieldAtom({ value: "DE10 ..." }) }],
    },
  ],
});

// Note that for nested component we stil provide the root form instance
// the path prop to array also starts from the root
const AdvancedNestedExample = () => {
  return (
    <ListField
      form={peopleForm}
      keyFrom="name"
      path={["people"]}
      builder={() => ({
        name: fieldAtom({ value: "" }),
        accounts: [],
      })}
    >
      {({ fields, index, add, RemoveItemButton }) => (
        <>
          <label>Person #{index}</label> <RemoveItemButton />
          <TextField field={fields.name} label="Name" />
          <ListField
            form={peopleForm}
            keyFrom="iban"
            path={["people", index, "accounts"]}
            builder={() => ({ iban: fieldAtom({ value: "" }) })}
          >
            {({ fields, index, RemoveItemButton }) => (
              <>
                <label>Account #{index}</label> <RemoveItemButton />
                <TextField field={fields.iban} label="IBAN" />
              </>
            )}
          </ListField>
        </>
      )}
    </ListField>
  );
};
```

### With RadioControl over the array items

<Canvas sourceState="none" of={ListFieldStories.WithRadioControl} />
