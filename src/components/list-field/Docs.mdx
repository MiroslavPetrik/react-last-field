import {
  Meta,
  Source,
  Canvas,
  Controls,
  Markdown,
  Description,
} from "@storybook/blocks";
import * as ListFieldStories from "./ListField.stories";
import Props from "./props.md?raw";

<Meta title="components/ListField" />

# ListField

The ListField component enables you to easily render & manage a [listField()](?path=/docs/fields-listField--docs). It is a higher order component, which internally uses the [useListField](?path=/docs/hooks-useListField--docs)
hook.

```ts
import { ListField } from "@form-atoms/field";
```

## Features

- ✅ **Performant rendering**. Each list item is rendered with a stable `key` derived from an internal form atom.
- ✅ Handles **adding, removal and ordering** of the list items with custom render props.
- ✅ **Blank Slate ready**. Can render a custom `<Empty />` component via render prop when the list is empty.
- ✅ **Reorder items** with pre-configured **`moveUp` & `moveDown` actions.**
- ✅ Supports **nested lists in lists**.

## Example

<Canvas sourceState="none" of={ListFieldStories.Primary} />

```tsx
import { listField, ListField, textField } from "@form-atoms/field";

const envVars = listField({
  value: [
    { variable: "GITHUB_TOKEN", value: "ff52d09a" },
    { variable: "NPM_TOKEN", value: "deepsecret" },
  ],
  builder: ({ variable, value }) => ({
    variable: textField({ name: "variable", value: variable }),
    value: textField({ name: "value", value: value }),
  }),
});

const Example = () => (
  <ListField
    field={envVars}
    AddButton={({ add }) => (
      <button type="button" className="secondary" onClick={add}>
        Add environment variable
      </button>
    )}
    RemoveButton={({ remove }) => (
      <button type="button" className="outline secondary" onClick={remove}>
        Remove
      </button>
    )}
  >
    {({ fields, RemoveButton }) => (
      <div
        style={{
          display: "grid",
          gridGap: 16,
          gridTemplateColumns: "auto auto min-content",
        }}
      >
        <InputField
          atom={fields.variable}
          render={(props) => <input {...props} placeholder="Variable Name" />}
        />
        <InputField
          atom={fields.value}
          render={(props) => <input {...props} placeholder="Variable Value" />}
        />
        <RemoveButton />
      </div>
    )}
  </ListField>
);
```

## Recipes

### List of primitive values

<Description of={ListFieldStories.ListOfPrimitiveValues} />

<Canvas sourceState="none" of={ListFieldStories.ListOfPrimitiveValues} />

```tsx
import { ListField, listField, textField } from "@form-atoms/field";

const productPros = listField({
  value: ["quality materials used", "not so heavy"],
  builder: (value) => textField({ value }),
});

const Example = () => (
  <>
    <label style={{ marginBottom: 16 }}>
      What are some benefits of TypeScript?
    </label>
    <ListField field={productPros}>
      {({ fields, RemoveButton }) => (
        <div
          style={{
            display: "grid",
            gridGap: 16,
            gridTemplateColumns: "auto min-content",
          }}
        >
          {/* IMPORTANT NOTE: when the list item contains primitive field, the `fields` prop is the primitive field atom: */}
          <InputField atom={fields} component="input" />
          <RemoveButton />
        </div>
      )}
    </ListField>
  </>
);
```

### `Empty` render prop

<Description of={ListFieldStories.EmptyRenderProp} />

<Canvas sourceState="none" of={ListFieldStories.EmptyRenderProp} />

```tsx
import { ListField, listField, textField } from "@form-atoms/field";

const productPros = listField({
  value: ["quality materials used", "not so heavy"],
  builder: (value) => textField({ value }),
});

// BEST PRACTICE: define your component statically. Avoid inline definitions when specifying props.
// NOTE: The `Empty` prop does not accept any props
const NoHobbiesCard = () => (
  <article>
    <p style={{ textAlign: "center" }}>
      You don't have any hobbies in your list. Start by adding your first one.
    </p>
  </article>
);

const Example = () => (
  <ListField field={fields.hobbies} Empty={NoHobbiesCard}>
    {({ fields, RemoveButton }) => (
      <div
        style={{
          display: "grid",
          gridGap: 16,
          gridTemplateColumns: "auto min-content",
        }}
      >
        <InputField atom={fields} component="input" />
        <RemoveButton />
      </div>
    )}
  </ListField>
);
```

### Nested

ListField supports nested array fields.
For example we can capture multiple people with multiple banking accounts:

<Canvas sourceState="none" of={ListFieldStories.Nested} />

```tsx
const peopleForm = formAtom({
  // level 0
  people: [
    {
      name: fieldAtom({ value: "Jerry" }),
      // level 1 (nested)
      accounts: [{ iban: fieldAtom({ value: "DE10 ..." }) }],
    },
  ],
});

// Note that for nested component we stil provide the root form instance
// the path prop to array also starts from the root
const AdvancedNestedExample = () => {
  return (
    <ListField
      form={peopleForm}
      keyFrom="name"
      path={["people"]}
      builder={() => ({
        name: fieldAtom({ value: "" }),
        accounts: [],
      })}
    >
      {({ fields, index, add, RemoveButton }) => (
        <>
          <label>Person #{index}</label> <RemoveButton />
          <TextField field={fields.name} label="Name" />
          <ListField
            form={peopleForm}
            keyFrom="iban"
            path={["people", index, "accounts"]}
            builder={() => ({ iban: fieldAtom({ value: "" }) })}
          >
            {({ fields, index, RemoveButton }) => (
              <>
                <label>Account #{index}</label> <RemoveButton />
                <TextField field={fields.iban} label="IBAN" />
              </>
            )}
          </ListField>
        </>
      )}
    </ListField>
  );
};
```

### With RadioControl over the array items

<Canvas sourceState="none" of={ListFieldStories.WithRadioControl} />
